*csupport.txt*                  C/C++ Support                      May 24 2007

C/C++ Support                                           *c-support* *csupport*
                              Plugin version 4.6
                        for Vim version 6.0 and above
                       Fritz Mehner  <mehner@fh-swf.de>

C/C++-IDE for Vim/gVim. It is written to considerably speed up writing code in
a consistent style.  This is done by inserting complete statements,idioms, code
snippets, templates, and comments.  Syntax checking, compiling,  running a
program, running a code checker or indent can be done with a keystroke.  


 1.    Usage                                    |csupport-usage-gvim|        
 1.1    Menu 'Comments'                         |csupport-comm|
 1.1.1   Append aligned comments                |csupport-comm-aligned|
 1.1.2   Realign end-of-line comments           |csupport-comm-realign|
 1.1.3   Multiline comment                      |csupport-comm-multiline|
 1.1.4   Code to comment                        |csupport-code-to-comm|
 1.1.5   Comment to code                        |csupport-comm-to-code|
 1.1.6   Frame comments, file header, ...       |csupport-comm-frame|
 1.1.7   KEYWORD + comment                      |csupport-comm-keywords|
 1.1.8   C to C++ comments and vice versa       |csupport-comm-c-cpp|
 1.1.9   Switch comment style                   |csupport-comm-style|
 1.2    Menu 'Statements'                       |csupport-stat|
 1.2.1   Normal mode, insert mode.              |csupport-stat-normal-mode|
 1.2.2   Visual mode.                           |csupport-stat-visual-mode|
 1.2.3   Make a switch from a label list        |csupport-stat-switch|
 1.2.4   Make cases from a label list           |csupport-stat-case|
 1.3    Menu 'Preprocessor'                     |csupport-prep|
 1.3.1   Normal mode, insert mode.              |csupport-prep-normal-mode|
 1.3.2   Visual mode.                           |csupport-prep-visual-mode|
 1.3.3   Block out code with "#if 0 .. #endif"  |csupport-prep-if0|
 1.4    Menu 'Idioms'                           |csupport-idioms|
 1.5    Menu 'Snippets'                         |csupport-snippets|
 1.5.1   Code snippets                          |csupport-snippets|
 1.5.2   Picking up prototypes                  |csupport-proto|
 1.6    Menu 'C++'                              |csupport-c++|
 1.6.1   Normal mode, insert mode.              |csupport-c++-normal-mode|
 1.6.2   Visual mode.                           |csupport-c++-visual-mode|
 1.6.3   Method implementation                  |csupport-c++-method-impl|
 1.7    Menu 'Run'                              |csupport-run|
 1.7.1   Minimal make functionality             |csupport-run-buffer|
 1.7.2   Command line arguments                 |csupport-run-cmdline-args|
 1.7.3   Run make                               |csupport-run-make|
 1.7.4   Command line arguments for make        |csupport-run-make-args|
 1.7.5   Splint                                 |csupport-run-splint|
 1.7.6   CodeCheck                              |csupport-run-codecheck|
 1.7.7   Indent                                 |csupport-run-indent|
 1.7.8   Hardcopy                               |csupport-run-hardcopy|
 1.7.9   Xterm size                             |csupport-run-xterm|
 1.7.10  Output redirection                     |csupport-run-output|
 1.8    Help                                    |csupport-help|

 2.    Usage without GUI                        |csupport-usage-vim|
 3.    Hotkeys                                  |csupport-hotkeys|           
 4.    Customization and configuration          |csupport-custom|     
 4.1    Global variables                        |csupport-custom-glob-vars|
 4.2    The root menu                           |csupport-custom-root-menu|
 5.    Template files and tags                  |csupport-templates|    
 5.1    Template files                          |csupport-templates|    
 5.2    Tags                                    |csupport-templates-tags|
 6.    C/C++ Dictionaries                       |csupport-dictionary|        
 7.    Extend taglist.vim for make and qmake    |csupport-taglist|     
 8.    Syntax based folding                     |csupport-folding|     
 9.    Windows particularities                  |csupport-windows|
10.    Troubleshooting                          |csupport-troubleshooting|
11.    Release Notes /Change Log                |csupport-release-notes|     

       How to add this help file to Vim's help  |add-local-help|             


==============================================================================
1.  USAGE WITH GUI  (gVim)                               *csupport-usage-gvim*
==============================================================================

If the root menu 'C/C++' is not visible call it with the item "Load C Support" 
from the standard Tools-menu.
The item "Load C Support" can also be used to unload the C/C++-root menu.

------------------------------------------------------------------------------
1.1  MENU 'Comments'                                           *csupport-comm*
------------------------------------------------------------------------------

1.1.1  APPEND ALIGNED COMMENTS TO CONSECUTIVE LINES    *csupport-comm-aligned*

In NORMAL MODE the menu items
 'end-of-line com. //' 
 'end-of-line com. /**/' 
will append the indicated comment to the current line. 

In VISUAL MODE these items will append aligned comments to all marked lines.
Marking the first 4 lines

  print_double_array ( double array[],
                       int    n,
                       int    columns,
                       char*  arrayname
                       )

and choosing 'end-of-line com. /**/' will yield.

  print_double_array ( double array[],          /*  */
                       int    n,                /*  */
                       int    columns,          /*  */
                       char*  arrayname         /*  */
                       )                        /*  */

If one ore more lines go beyond the starting column (s.below) the comments
will start at the 2. column after the longest line.  The cursor will be
positioned inside the first comment.

The default starting column is 49 ( = (multiple of 2,4, or 8) + 1 ).  This can
be changed by setting a global variable in the file .vimrc , e.g. :

  let g:C_LineEndCommColDefault    = 45

The starting column can also be set by the menu item 
'Comments->set end-of-line com. col' . Just position the cursor in an
arbitrary column (column number is shown in the Vim status line) and choose
this menu item.  This setting is buffer related.

If the cursor was at the end of a line you will be asked for a column number
because this position is most likely not the desired starting column.
Your choice will be confirmed.

------------------------------------------------------------------------------

1.1.2  REALIGN END-OF-LINE COMMENTS                    *csupport-comm-realign*

After some changes end-of-line comments may be no longer aligned:

  print_double_array ( double       array[],          /*  */
                       long int     n,                     /*  */
                       unsigned int columns,          /*  */
                       char*        a_name         /*  */
                       )                        /*  */

Realignment can be achieved with the menu item 'adjust end-of-line com.' In
normal mode the comment (if any) in the current line will be aligned to the
end-of-line comment column (see above) if possible. In visual mode the
comments in the marked block will be aligned:

  print_double_array ( double       array[],    /*  */
                       long int     n,          /*  */
                       unsigned int columns,    /*  */
                       char*        a_name      /*  */
                       )                        /*  */

------------------------------------------------------------------------------

1.1.3  MULTILINE COMMENT                             *csupport-comm-multiline*

NORMAL MODE, INSERT MODE. The comment shown below will be inserted.

  /*
   * 
   */

VISUAL MODE. A marked block

xxxxxxxx
xxxxxxxx

will be changed into a multiline comment (all (partially) marked lines):

/* xxxxxxxx
 * xxxxxxxx
 */


------------------------------------------------------------------------------

1.1.4  CODE TO COMMENT                                 *csupport-code-to-comm*

When 'comment style C' is active (see |csupport-comm-style| for switching) a
marked block

xxxxxxxx
xxxxxxxx
xxxxxxxx

will be changed by the menu item 'code->comment' into a multiline comment
(all (partially) marked lines):

/* xxxxxxxx
 * xxxxxxxx
 * xxxxxxxx
 */

When 'comment style C++' is active the marked block will be changed into

// xxxxxxxx
// xxxxxxxx
// xxxxxxxx

The menu item works also for a single line. A single line needs not to be
marked. 

------------------------------------------------------------------------------

1.1.5  COMMENT TO CODE                                 *csupport-comm-to-code*

If one (or more) complete comment (i.e. all lines belonging to the comment) is
marked the item 'comment->code' will uncomment it.  If the following lines
are marked

   * printf ("\n");
   */

  printf ("\n");

  //  printf ("\n");
  //

  /* 
   *  printf ("\n");
   */

uncommenting will yield

   * printf ("\n");
   */

  printf ("\n");

  printf ("\n");



  printf ("\n");

The first 2 lines are only a part of a C-comment and remain unchanged.
A C-comment can start with /* , /** or /*! .
The menu item 'comment->code' does not depend on the currently set comment
style (C/C++).

The menu item works also for a single line with a leading // . A single line
needs not to be marked. 

------------------------------------------------------------------------------

1.1.6  FRAME COMMENTS, FILE HEADER, ...                  *csupport-comm-frame*

Frame comments, file header comments and function, methods, class descriptions 
are read as templates from the appropriate files (see |csupport-templates|).

------------------------------------------------------------------------------

1.1.7  KEYWORD+comment                                *csupport-comm-keywords*

Preliminary comments to document (and find again) places where works will be
resumed shortly. Usually not meant for the final documentation.

------------------------------------------------------------------------------

1.1.8  C TO C++ COMMENTS AND VICE VERSA                  *csupport-comm-c-cpp*

The menu item '// xxx -> /* xxx */' changes a C++ comment into an C comment.
This is done for the current line in normal or insert mode and for a marked
area of lines in visual mode.
This menu item changes to '/* xxx */ -> // xxx' if the comment style is switched
(see below).
If there are multiple C comments only the first one will be changed:
  printf ("\n");                     /* one */ /* two */ /* three */
will be changed into
  printf ("\n");                     // one  /* two */ /* three */

------------------------------------------------------------------------------

1.1.9  SWITCH COMMENT STYLE                              *csupport-comm-style*

The item 'Comment style C -> C++' changes the comment style to C++ style.
The item 'Comment style C++ -> C' changes the comment style back to C style.

Inserted do-while with C-style comment:

  do
  {
  }
  while (  );       /* -----  end do-while  ----- */


Inserted do-while with C++-style comment:

  do
  {
  }
  while (  );       // -----  end do-while  ----- 

AUTO-TOGGLE. If the global variable g:C_CommentsToggle is set to 'yes' (in
'.vimrc'; default is 'no') the comment style changes with the filetype of the
current buffer.  This setting can be changed during a session using the Ex
command
 
  :CSetCCommentsToggle no

(values 'yes' or 'no'). Start typing ':CS' und use the tabulator to complete
the command.

------------------------------------------------------------------------------
1.2  MENU 'Statements'                                         *csupport-stat*
------------------------------------------------------------------------------

1.2.1  NORMAL MODE, INSERT MODE.                   *csupport-stat-normal-mode*

An empty statement will be inserted and properly indented. The item 'if{}'
will insert an if-statement:

if (  )
{
}

The opening curly brace will be put in a new line. To enable Kernighan &
Ritchie style 

if (  ) {
}

set the appropriate global variable in .vimrc :

  let g:C_BraceOnNewLine     = "no"   

The default values is "yes".  This flag applies to all structural blocks,
excluding subroutines and classes. 
This setting can be changed during a session using the Ex command
 
  :CSetBraceOnNewLine yes

(values 'yes' or 'no'). Start typing ':CS' und use the tabulator to complete
the command.


1.2.2  VISUAL MODE.                                *csupport-stat-visual-mode*

STATEMENTS WITH BLOCKS AND CASE LABEL.  
--------------------------------------
The highlighted area 

xxxxx
xxxxx

can be surrounded by one of the following statements:

  +----------------------------+-----------------------------+
  |     if (  )                |     if (  )                 |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  |                            |     else                    |
  |                            |     {                       |
  |                            |     }                       |
  +----------------------------+-----------------------------+
  |     for ( ; ;  )           |     while (  )              |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  +----------------------------+-----------------------------+
  |     do                     |                             |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  |     while (  );            |                             |
  +----------------------------+-----------------------------+

For 'switch' and 'case' see |csupport-stat-switch| and |csupport-stat-case|.

The whole statement will be indented after insertion.


STATEMENTS WITHOUT BLOCKS.  
--------------------------
Above the highlighted lines 

xxxxx
xxxxx

one of the following statements can be inserted:

  +-------------------------------+--------------------------+
  |    if (  )                    |    for ( ; ;  )          |
  |      xxxxx                    |      xxxxx               |
  |    xxxxxxx                    |    xxxxx                 |
  +-------------------------------+--------------------------+
  |    if (  )                    |    while (  )            |
  |      xxxxx                    |      xxxxx               |
  |    xxxxx                      |    xxxxx                 |
  |    else                       |                          |
  +-------------------------------+--------------------------+

The lines will be indented after insertion.


1.2.3   MAKE A SWITCH FROM A LABEL LIST                 *csupport-stat-switch*

The menu item "switch {}" can be used to convert a list of labels (one in a
line) into a switch statement. A visually marked list of labels, e.g. 

 (   Default, /* a comment */
 Red,
 Green,
 Blue=777 );

extracted from an enum, will be changed into

  switch (  )
  {
    case Default: 
      break;

    case Red: 
      break;

    case Green: 
      break;

    case Blue: 
      break;

    default:  
      break;
  }       /* -----  end switch  ----- */

The label will be the first word ("\w\+") of each line, leading and trailing
non-word characters (including whitespaces) will be discarded.  Empty lines
will be skipped.


1.2.4   MAKE CASES FROM A LABEL LIST                      *csupport-stat-case*

The menu item "case ... break" can be used to convert a marked list of raw
labels (one in a line) inside a switch into empty cases, e.g. 

  switch (  ) {
    case Red: 
      break;
  
    case Green: 
      break;

Blue            << marked line
LightBlue       << marked line
DarkBlue        << marked line
  }       /* -----  end switch  ----- */

extracted from an enum, will be changed into

  switch (  ) {
    case Red: 
      break;
  
    case Green: 
      break;

    case Blue: 
      break;

    case LightBlue: 
      break;

    case DarkBlue: 
      break;

  }       /* -----  end switch  ----- */


The label will be the first word ("\w\+") of each line, leading and trailing
non-word characters (including whitespaces) will be discarded.  Empty lines
will be skipped.

------------------------------------------------------------------------------
1.3  MENU 'Preprocessor'                                       *csupport-prep*
------------------------------------------------------------------------------

1.3.1  NORMAL MODE, INSERT MODE.                   *csupport-prep-normal-mode*

The preprocessor statements will be inserted and properly indented. 

1.3.2  VISUAL MODE.                                *csupport-prep-visual-mode*

STATEMENTS WITH BLOCKS
----------------------
The highlighted area 

xxxxx
xxxxx

can be surrounded by one of the following statements:

  +----------------------------+-----------------------------+
  |    #if  CONDITION                                        |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #if CONDITION  ----- */           |
  |                                                          |
  |    #endif     /* ----- #if CONDITION  ----- */           |
  +----------------------------------------------------------+
  |    #ifdef  CONDITION                                     |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #ifdef CONDITION  ----- */        |
  |                                                          |
  |    #endif     /* ----- #ifdef CONDITION  ----- */        |
  +----------------------------------------------------------+
  |    #ifndef  CONDITION                                    |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #ifndef CONDITION  ----- */       |
  |                                                          |
  |    #endif     /* ----- #ifndef CONDITION  ----- */       |
  +----------------------------------------------------------+
  |    #ifndef  INC_TEST                                     |
  |    #define  INC_TEST                                     |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #endif   /* ----- #ifndef INC_TEST  ----- */          |
  +----------------------------------------------------------+
  |    #if  0     /* ----- #if 0 : If0Label_1 ----- */       |
  |                                                          |
  |    #endif     /* ----- #if 0 : If0Label_1 ----- */       |
  +----------------------------------------------------------+

The macro name for an include guard (e.g. INC_TEST above) will be derived as a
suggestion from the file name.  

1.3.3  BLOCK OUT CODE WITH  "#if 0 ... #endif"             *csupport-prep-if0*

The menu item "#if 0 #endif" inserts the lines

  #if  0     /* ----- #if 0 : If0Label_1 ----- */

  #endif     /* ----- #if 0 : If0Label_1 ----- */

In visual mode the marked block of lines will be surrounded by these lines.

This is usually done to temporarily block out some code.  The label names like
If0Label_1 are automatically inserted into the comments.  The trailing numbers
are automatically incremented.  These numbers can be changed by the user.  The
next number will be one above the highest number found in the current buffer.

A corresponding label can be found by searching with the vim star command (*).
All labels can be found with a global search like :g/If0Label_/ or
:g/If0Label_\d\+/. All corresponding lines can be deleted with :g/If0Label_/d .


REMOVE THE ENCLOSING "#if 0 ... #endif"-CONSTRUCT.

The menu item 'remove #if #endif' removes such a construct if the cursor is
in the middle of such a section or on one of the two enclosing lines. Nested
constructs will be untouched.

------------------------------------------------------------------------------
1.4  MENU 'Idioms'                                           *csupport-idioms*
------------------------------------------------------------------------------

1.4.1  ENTRY 'function'

NORMAL MODE, INSERT MODE: 
The name of the function is asked for and the following lines (for function
name "f") will be inserted:

  void
  f (  )
  {
    return ;
  }        /* ----------  end of function f  ---------- */

VISUAL MODE: 
Main or [static] function: the highlighted lines will go inside the new
function or main. 
for-loops: the highlighted lines will be set in braces.

1.4.2  ENTRY 'open input file'

The item 'open input file' will create the statements to open and close an
input file (e.g. with the file pointer 'infile'). 
After the insertion the Idioms-menu has the additional item 
'fscanf(infile,"",);'  which generates the following line:

 fscanf( infile, "", & );

1.4.3  ENTRY 'open output file'

The item 'open output file' will create the statements to open and close an
output file (e.g. with the file pointer 'outfile'). 
After the insertion the Idioms-menu has the additional item 
'fprintf(outfile,"\n",);'   which generates the following line

 fprintf( outfile, "\n",  );

------------------------------------------------------------------------------
1.5  MENU 'Snippets'                                       *csupport-snippets*
------------------------------------------------------------------------------

1.5.1  CODE SNIPPETS                                    

Code snippets are pieces of code which are kept in separate files in a special
directory (e.g. a few lines of code or a complete template for a Makefile).
File names are used to identify the snippets.  The snippet directory will be
created during the installation  ( $HOME/.vim/codesnippets-c is the default).
Snippets are managed with the 3 items 

   C/C++ -> Snippets -> read  code snippet
   C/C++ -> Snippets -> write code snippet
   C/C++ -> Snippets -> edit  code snippet

from the Snippets submenu.

CREATING A NEW SNIPPET  
When nothing is marked, "write code snippet" will write the whole buffer 
to a snippet file, otherwise the marked area will be written to a file.

INSERT A SNIPPET
Select the appropriate file from the snippet directory ("read  code snippet").
The inserted lines will be indented.

EDIT A SNIPPET
This is a normal edit.

INDENTATION / NO INDENTATION
Code snippets are normally indented after insertion. To suppress indentation
add the file extension "ni" or "noindent" to the snippet file name, e.g.

  parameter_handling.c.noindent


1.5.2   PICKING UP PROTOTYPES                                 *csupport-proto*

PICK UP PROTOTYPES.  
To make a prototype from a function head mark the function head and choose
'Snippets -> pick up prototype'. From the first six lines of

   void
  print_double_array (  double array[],  /* array to print                */
                        int    n,        /* number of elements to print   */
                        int    columns,  /* number of elements per column */
                        char*  arrayname /* array name                    */
                        )
  {
    ...
  }       /* ----------  end of function print_double_array  ---------- */

the prototype

  void print_double_array ( double array[], int n, int columns, char* arrayname );

is produced and put in an internal buffer. 
- Leading and trailing whitespaces are removed. 
- All inner whitespaces are squeezed. 
- All comments will be discarded.
- Trailing parts of the function body (e.g a '{' ) will also be removed.
- The class name and the scope resolution operator will be removed (C++ method
  implementations).
Further prototypes can be picked up and gathered in the buffer.

For C++ methods namespace names and class names will be removed
(exception: 'std::' ). The first two lines of

  std::string
  ROBOT::Robot::get_name  ( void )
  {
    return type_name;
  }   /* -----  end of method Robot::get_name  ----- */

result in the prototype

  std::string get_name ( void );

Folding may help picking up prototypes (see |csupport-folding|).


INSERT PROTOTYPES  
With 'Snippets -> insert prototype(s)' all picked up prototypes currently in
the buffer will be inserted below the cursor.
The prototype buffer will be cleared after insertion.


DISCARD PROTOTYPES  
The prototype buffer can be cleared with 'Snippets -> clear prototype(s)' .


SHOW PROTOTYPES  
The list of gathered prototypes can be shown with 
'Snippets -> show prototype(s)'. The number and the filename are shown, e.g. 

  (1) matrix.c #  double** calloc_double_matrix ( int rows, int columns );
  (2) matrix.c #  void free_double_matrix ( double **m );
  (3) foomain.c #  void foo ( );


REMARK. Generating prototypes this way is nice in a small project. You may
want to use an extractor like cextract or something else. 


------------------------------------------------------------------------------
1.6  MENU 'C++'                                                 *csupport-c++*
------------------------------------------------------------------------------

1.6.1  NORMAL MODE, INSERT MODE.                    *csupport-c++-normal-mode*

An empty statement will be inserted and in some cases properly indented. The
item 'try .. catch' will insert the following 10 lines:

  try
  {
    |
  }
  catch ( const &ExceptObj )    /* handle exception: */
  {
  }
  catch (...)      /* handle exception: unspezified */
  {
  }

The cursor will go into the try block.

1.6.2  VISUAL MODE.                                 *csupport-c++-visual-mode*

The highlighted area can be surrounded by one of the following statements:

  try - catch
  catch
  catch(...)
  namespace { }
  extern "C" { }

The whole statement will be indented after insertion.

1.6.3   METHOD IMPLEMENTATION                       *csupport-c++-method-impl*

The menu item 'method implement.' asks for a method name. If this item is
called the first time you will see just an scope resolution operator.  If you
specify the scope this is used the next time you call this item.  If you use
one of the menu items to generate a class (see |csupport-templates|) the
scope will be extracted and used for the next method.  The scope can be
changed by an Ex command:

  :CSetClassName newClass

Start typing ':CS' und use the tabulator to complete the command.

------------------------------------------------------------------------------
1.7  MENU 'Run'                                                 *csupport-run*
------------------------------------------------------------------------------

1.7.1  MINIMAL MAKE FUNCTIONALITY                        *csupport-run-buffer*

The 'Run' menu provides a minimal make functionality for single file projects
(e.g. in education) :

SAVE AND COMPILE
'save and compile' saves the buffer and run the compiler with the given
options (see |csupport-custom-glob-vars|).

An error window will be opened if the compiler reports errors and/or warnings.
Quickfix commands can now be used to jump to an error location.

Consider using maps like 
  map  <silent> <F7>    <Esc>:cp<CR>
  map  <silent> <F8>    <Esc>:cn<CR>
in your .vimrc file to jump over the error locations and make navigation
easier.  The error list and the error locations in your source buffer will be
synchronized.


LINK
'link' makes an executable from the current buffer. If the buffer is not
saved, or no object is available or the object is older then the source step
'save and compile' is executed first.

The behavior of the compiler / linker is determined by the options assigned to
the variables described in |csupport-custom-glob-vars| (4.group).

RUN
'run' runs the executable with the same name (extension .e) as the current
buffer. If the buffer is not saved, or no executable is available or the
executable is older then the source steps 'save and compile' and 'link' are
executed first.


1.7.2  COMMAND LINE ARGUMENTS                      *csupport-run-cmdline-args*

The item 'command line arguments' calls an input dialog which asks for command
line arguments. These arguments are forwarded to the program which is run by
the 'run' item. The arguments are kept until you change them.

The arguments belong to the current buffer (that is, each buffer can have its 
own arguments).
If the buffer gets a new name with "save as" the arguments will now belong to
the buffer with the new name.

The command line arguments can be followed by pipes and redirections:

  11 22 | sort -rn | head -10 > out

Caveat: If you look for the current arguments by calling this menu item again
be sure to leave it with a CR (not Esc !). Due to a limitation of an internal
Vim function CR will keep the arguments, Esc with discard them.


1.7.3  RUN make                                            *csupport-run-make*

The item 'make' runs the external make program.


1.7.4  COMMAND LINE ARGUMENTS FOR make                *csupport-run-make-args*

The item 'command line arguments for make' calls an input dialog which asks
for command line arguments for make. These arguments are forwarded to make
when called by the item 'make'.


1.7.5  SPLINT                                            *csupport-run-splint*

Splint is a tool for statically checking C programs (see http://www.splint.org).
Of course it has to be installed in order to be used within Vim.  The menu
item 'Run->splint' will run the current buffer through splint.

An error window will be opened if splint has something to complain about.
Quickfix commands can now be used to jump to an error location.  For easier
navigation see tip under 'SAVE AND COMPILE' |csupport-run-buffer|.

Splint has many options. Presumably the best way is to keep the options in an
option file (~/.splintrc). For a quick try you can use the menu item
'Run->cmd. line arg. for splint' to specify some buffer related options.  

When vim is started this plugin will check whether splint is executable. If
not, the menu item will *NOT' be visible.


1.7.6  CODECHECK                                      *csupport-run-codecheck*

CodeCheck (TM) is a commercial code analyzing tool produced by Abraxas
Software, Inc.  (www.abraxas-software.com).
Of course it has to be installed in order to be used within Vim.  The menu
item 'Run->CodeCheck' will run the current buffer through CodeCheck.

An error window will be opened if CodeCheck has something to complain about.
Quickfix commands can now be used to jump to an error location.  For easier
navigation see tip under 'SAVE AND COMPILE' |csupport-run-buffer|.

CodeCheck has many options.  For a quick try you can use the menu item
'Run->cmd. line arg. for CodeCheck' to specify some buffer related options.  

CodeCheck will be run with default options (see |csupport-custom-glob-vars|).
The default options can be overwritten by  placing a global variable in
.vimrc , e.g.

  let  g:C_CodeCheckOptions = "-K13 -Rmeyers"

The default name for the executable is 'check'.  There are other names in use
on different platforms.  The name can be changed by placing a global variable
in .vimrc , e.g.

  let  g:C_CodeCheckExeName = "chknt.exe"

When vim is started this plugin will check whether CodeCheck is executable. If
not, the menu item will *NOT' be visible.


1.7.7  INDENT                                            *csupport-run-indent*

The formatter 'indent' can be run over the whole buffer or a marked region.
Before formatting the whole buffer this buffer will be saved to disk and you
will be asked for a confirmation.

Indent has many options. These are kept in the file '.indent.pro' in your home
directory. See the indent manual for more information.


1.7.8  HARDCOPY                                        *csupport-run-hardcopy*

Generates a PostScript file from the whole buffer or from a marked region.
On a Windows system a printer dialog is displayed.

The print header contains date and time for the current locale. The definition
used is
 
  let s:C_Printheader = "%<%f%h%m%<  %=%{strftime('%x %X')}     Page %N"

The current locale can be overwritten by changing the language, e.g. 

  :language C

or by setting a global variable in the file .vimrc , e.g. :

  let g:C_Printheader = "%<%f%h%m%<  %=%{strftime('%x %X')}     SEITE %N"

See :h printheader and :h strftime()  for more details. 


1.7.9  XTERM SIZE                                         *csupport-run-xterm*

The size of the xterm used for  running a program (below) can be set by this
menu item. The default is 80 columns with 24 lines.  
This feature is not available under Windows.


1.7.10  OUTPUT REDIRECTION                               *csupport-run-output*

Running a program can be done in one of three ways:
(1) Run the program from the gVim command line.
    This is for interactive programs with little input and output.
(2) Run the program and direct the output into a window with name "C-Output".
    The buffer and its content will disappear when the window is closed and 
    reused otherwise.
    This is for non-interactive programs with little to very much output.
    You have unlimited line length, regex search, navigation, ...
(3) Run the program in an xterm.

The output method can be chosen from the menu item 'Run->output: ...'.
This menu has three states:
 
  output: VIM->buffer->xterm
  output: BUFFER->xterm->vim
  output: XTERM->vim->buffer

The first (uppercase) item shows the current method.  The default is 'vim'.
This can be changed by setting the variable g:C_OutputGvim to another value.
Possible values are 'vim', 'buffer' and 'xterm' .

The xterm defaults can be set in .vimrc by the variable g:C_XtermDefaults .
The default is "-fa courier -fs 12 -geometry 80x24" :
  font name     : -fa courier
  font size     : -fs 12
  terminal size : -geometry 80x24
See 'xterm -help' for more options. Xterms are not available under Windows.

------------------------------------------------------------------------------
1.8  'help'                                                    *csupport-help*
------------------------------------------------------------------------------

The root menu item 'help' shows this plugin help in a help window.  The help
tags must have been generated with
  :helptags ~/.vim/doc

==============================================================================
2.  USAGE WITHOUT GUI  (Vim)                              *csupport-usage-vim*
==============================================================================

The frequently used constructs can be inserted with key mappings.  The
mappings are also described in the document c-hot-keys.pdf (reference card,
part of this package).
Hint: Typing speed matters. The combination of a leader ('\') and the
following character(s) will only be recognized for a short time.
The insert mode mappings start with ` (backtick).  

Legend:  (i) insert mode, (n) normal mode, (v) visual mode

  -- Load / Unload C/C++ Support ----------------------------------------

  \lcs      Load C/C++ Support Menus            (n, GUI only)}
  \ucs      Unload C/C++ Support Menus          (n, GUI only)}

  -- Comments -----------------------------------------------------------

  \cl       end-of-line comment                 (n,v,i)
  \cj       adjust end-of-line comment(s)       (n,v,i)
  \cs       set end-of-line comment column      (n)
  \ci       multiline comment /**/              (n,v)
  \c*       code -> comment /**/                (n,v)
  \c\       code -> comment //                  (n,v)
  \co       comment -> code /**/                (n,v)
  \cf       frame comment                       (n,i)
  \cfu      function comment                    (n,i)
  \cm       method description                  (n,i)
  \ca       class description                   (n,i)
  \cd       date                                (n,i)
  \ct       date \& time                        (n,i)
  \cy       change comment style                (n)

  -- Statements ---------------------------------------------------------

  \sd       do { } while                        (n,v,i)
  \sf       for                                 (n,v,i)
  \sfo      for { }                             (n,v,i)
  \si       if                                  (n,v,i)
  \sif      if { }                              (n,v,i)
  \sie      if else                             (n,v,i)
  \sife     if { } else { }                     (n,v,i)
  \sw       while                               (n,v,i)
  \swh      while { }                           (n,v,i)
  \ss       switch                              (n,v,i)
  \sc       case                                (n,v,i)
  \s{       { }                                 (n,v,i)

  -- Preprocessor -------------------------------------------------------

  \p<       #include <>                         (n,i)
  \p"       #include ""                         (n,i)
  \pd       #define                             (n,i)
  \pu       #undef                              (n,i)
  \pie      #if  #else  #endif                  (n,v,i)
  \pid      #ifdef  #else  #endif               (n,v,i)
  \pin      #ifndef #else  #endif               (n,v,i)
  \pind     #ifndef #def  #endif                (n,v,i)
  \pi0      #if 0 #endif                        (n,v,i)
  \pr0      remove  '#if  0 #endif'             (n) 
  -- Idioms -------------------------------------------------------------

  \if       function                            (n,v,i)
  \isf      static function                     (n,v,i)
  \im       main()                              (n,v,i)
  \i0       for( x=0; x<n; x+=1 )               (n,v,i)
  \in       for( x=n-1; x>=0; x-=1 )            (n,v,i)
  \ie       enum   + typedef                    (n,i)
  \is       struct + typedef                    (n,i)
  \iu       union  + typedef                    (n,i)
  \ip       printf()                            (n,i)
  \isc      scanf()                             (n,i)
  \ica      p=calloc()                          (n,i)
  \ima      p=malloc()                          (n,i)
  \isi      sizeof()                            (n,v,i)
  \ias      assert()                            (n,v,i)
  \ii       open input file                     (n,i)
  \io       open output file                    (n,i)

  -- Snippets -----------------------------------------------------------

  \nr       read code snippet                   (n & GUI only)
  \nw       write code snippet                  (n,v & GUI only)
  \ne       edit code snippet                   (n & GUI only)
  \np       pick up prototype                   (n,v)
  \ni       insert prototype(s)                 (n)
  \nc       clear  prototype(s)                 (n)
  \ns       show   prototype(s)                 (n)

  -- C++ ----------------------------------------------------------------

  \+m       method implementation               (n,i)
  \+c       class                               (n,i)
  \+cn      class (using new)                   (n,i)
  \+ec      error class                         (n,i)
  \+t       template class                      (n,i)
  \+tn      template class (using new)          (n,i)
  \+tf      template function                   (n,i)
  \+tr      try ... catch                       (n,v,i)
  \+ca      catch                               (n,v,i)
  \+c.      catch(...)                          (n,v,i)

  -- Run ----------------------------------------------------------------

  \rc       save and compile                    (n)
  \rl       link                                (n)
  \rr       run                                 (n)
  \ra       set comand line arguments           (n)
  \rm       run make                            (n)
  \rg       cmd. line arg. for make             (n)
  \rp       run splint                          (n)
  \ri       cmd. line arg. for splint           (n)
  \rd       run indent                          (n,v)
  \rh       hardcopy buffer                     (n,v)
  \rs       show plugin settings                (n)
  \rx       set xterm size                      (n, only Linux/UNIX & GUI)
  \ro       change output destination           (n)

The hotkeys are defined in the file type plugin c.vim (part of this csupport
plugin package) and described in the document c-hot-keys.pdf

==============================================================================
3.  HOTKEYS                                                 *csupport-hotkeys*
==============================================================================

The following hotkeys are defined in normal, visual and insert mode: 

       F9   compile and link
   Alt-F9   write buffer and compile
  Ctrl-F9   run executable
 Shift-F9   set command line arguments

 Shift-F2   switch between source files and header files

Shift-F2 can be used to switch between source files and header files if the
plugin a.vim is present.  To suppress the creation of a new header file when
switching from a source file the file .vimrc should contain a line  

  let g:alternateNoDefaultAlternate = 1

A header file will only be opened if it already exists.

The hotkeys are defined in the file type plugin  c.vim .

All hotkeys from the non-GUI mode also work for gVim (see |csupport-usage-vim|).

==============================================================================
4.  CUSTOMIZATION                                            *csupport-custom*
==============================================================================

------------------------------------------------------------------------------
4.1  GLOBAL VARIABLES                              *csupport-custom-glob-vars*
------------------------------------------------------------------------------

Several global variables are checked by the script to customize it:

  ----------------------------------------------------------------------------
  GLOBAL VARIABLE           DEFAULT VALUE                    TAG (see below)
  ----------------------------------------------------------------------------
  g:C_AuthorName            ""                               |AUTHOR|
  g:C_AuthorRef             ""                               |AUTHORREF|
  g:C_Email                 ""                               |EMAIL|
  g:C_Company               ""                               |COMPANY|   
  g:C_Project               ""                               |PROJECT|
  g:C_CopyrightHolder       ""                               |COPYRIGHTHOLDER|

  g:C_Template_Directory    plugin_dir."c-support/templates/"
  g:C_Template_C_File       "c-file-header"
  g:C_Template_Class        "c-class-description"
  g:C_Template_Frame        "c-frame"
  g:C_Template_Function     "c-function-description"
  g:C_Template_H_File       "h-file-header"
  g:C_Template_Method       "c-method-description"
  g:Cpp_Template_C_File     "cpp-file-header"
  g:Cpp_Template_Class      "cpp-class-description"
  g:Cpp_Template_Frame      "cpp-frame"
  g:Cpp_Template_Function   "cpp-function-description"
  g:Cpp_Template_H_File     "hpp-file-header"
  g:Cpp_Template_Method     "cpp-method-description"

  g:C_BraceOnNewLine        "no"   
  g:C_Comments              "yes"
  g:C_CommentsToggle        "no"
  g:C_CodeSnippets          plugin_dir."/c-support/codesnippets/"
  g:C_Dictionary_File       ""
  g:C_LoadMenus             "yes"
  g:C_MenuHeader            "yes"
  g:C_OutputGvim            "vim"
  g:C_XtermDefaults         "-fa courier -fs 12 -geometry 80x24"
  g:C_Printheader           "%<%f%h%m%<  %=%{strftime('%x %X')}     Page %N"

  Linux/UNIX: 
   g:C_ObjExtension         ".o"
   g:C_ExeExtension         ""
   g:C_CCompiler            "gcc"            
   g:C_CplusCompiler        "g++"            
  Windows:
   g:C_ObjExtension         ".obj"
   g:C_ExeExtension         ".exe"
   g:C_CCompiler            "gcc.exe"            
   g:C_CplusCompiler        "g++.exe"            
  g:C_CFlags                "-Wall -g -O0 -c"
  g:C_LFlags                "-Wall -g -O0"   
  g:C_Libs                  "-lm"            
  g:C_LineEndCommColDefault 49
  g:C_CExtension            "c"              

  g:C_CodeCheckExeName      "check"
  g:C_CodeCheckOptions      "-K13"

The variable plugin_dir will automatically be set to one of the following values:
  $HOME.'/.vim/'        for Linux/Unix
  $VIM.'/vimfiles/'     for Windows

  ----------------------------------------------------------------------------

1. group: Defines the text which will be inserted for the tags when a template  
          is read in (see also |csupport-templates| below).

          g:C_AuthorName         : author name
          g:C_AuthorRef          : author reference (e.g. acronym)
          g:C_Email              : email address
          g:C_Company            : name of the company / institution
          g:C_Project            : project
          g:C_CopyrightHolder    : the copyright holder

2. group: g:C_Template_Directory : Sets the template directory and the names of the 
           ...                     template files (see |csupport-templates|).

3. group: g:C_BraceOnNewLine     : block statements: opening curly brace on a
                                   new line / not on a new line
          g:C_Comments           : The initial comment style (C = yes, C++ = no).
          g:C_CommentsToggle     : Comment style (C/C++) automatically follows file type.
          g:C_CodeSnippets       : The name of the code snippet directory 
                                   (see |csupport-snippets|).
          g:C_Dictionary_File    : The name(s) of the dictionary file(s) used for 
                                   word completion (see also |csupport-dictionary|)
          g:C_Root               : the name of the root menu of this plugin
          g:C_LoadMenus          : Load menus and mappings ("yes", "no") at startup.
          g:C_MenuHeader         : Switch the submenu header on/off.
          g:C_OutputGvim         : when program is running output goes to the vim 
                                   command line ("vim"), to a buffer ("buffer") or to
                                   an xterm ("xterm").
          g:C_XtermDefaults      : the xterm defaults
          g:C_Printheader        : hardcopy: definition of the page header 

4. group: g:C_CExtension             : Extension of C files. Everything else is C++.
          g:C_CCompiler              : The name of the C compiler.
          g:C_CplusCompiler          : The name of the C++ compiler.
          g:C_CFlags                 : Compiler flags used for a compilation.
          g:C_LFlags                 : Compiler flags used for linkage.
          g:C_Libs                   : Libraries to link with.
          g:C_ObjExtension           : C/C+ file extension for objects
                                       (leading point required if not empty)
          g:C_ExeExtension           : C/C+ file extension for executables 
                                       (leading point required if not empty)
          g:C_LineEndCommColDefault  : Default starting column for end-of-line comments.
          g:C_CodeCheckExeName       : The name of the CodeCheck (TM) executable
                                       (the default is 'check')
          g:C_CodeCheckOptions       : Default options for CodeCheck (TM) 
                                       (see |csupport-run-codecheck|).

To override the default add appropriate assignments to .vimrc .
Here are my settings as an example:

  let g:C_AuthorName      = "Dr.-Ing. Fritz Mehner"    
  let g:C_AuthorRef       = "Mn"                       
  let g:C_Email           = "mehner@fh-swf.de"         
  let g:C_Company         = "FH Südwestfalen, Iserlohn"


------------------------------------------------------------------------------
4.2  THE ROOT MENU                                 *csupport-custom-root-menu*
------------------------------------------------------------------------------

The variable g:C_Root, if set (in .vimrc or in .gvimrc), gives the name of the
single Vim root menu item in which the C/C++ submenus will be put. 
The default is 
                  '&C\/C\+\+.'
Note the terminating dot. A single root menu can be used if the screen is
limited or several plugins are used in parallel.

If set to "", this single root menu item will not appear.  Now all submenus
are put into the Vim root menu. This is nice for beginners in a lab
installation or for C-only programmers.


==============================================================================
5.  TEMPLATE FILES AND TAGS                               *csupport-templates*
==============================================================================

------------------------------------------------------------------------------
5.1  TEMPLATE FILES
------------------------------------------------------------------------------

Many menu items generate comments or commented code. The style of these 
comments can be toggled between C-style ( /*...*/ ) and C++-style ( //... ). 
Two menu items have a fixed style ( C-/C++ end-of-line comment)

Six menu items generate block comments:

    C/C++-file header
    Class Description
    Frame Comment
    Function Description
    H-file header
    Method Description

The comments which will be inserted by these menus items are read from files:

+--------------------------+--------------------------------------------------------+
| menu item               | global variable           | file (distribution set)    |
+--------------------------+---------------------------+----------------------------+
| C/C++-file header        | g:C_Template_C_File       | c-file-header              |
| Class Description        | g:C_Template_Class        | c-class-description        |
| Frame Comment            | g:C_Template_Frame        | c-frame                    |
| Function Description     | g:C_Template_Function     | c-function-description     |
| H-file header            | g:C_Template_H_File       | h-file-header              |
| Method Description       | g:C_Template_Method       | c-method-description       |
| class                    | g:C_Class                 | c-class                    |
| class using new          | g:C_ClassUsingNew         | c-class-using-new          |
| template class           | g:C_TemplateClass         | c-template-class           |
| template class using new | g:C_TemplateClassUsingNew | c-template-class-using-new |
| error class              | g:C_ErrorClass            | c-error-class              |
+--------------------------+--------------------------------------------------------+

There may be a second set of files pointed to by the global variables whose 
names start with  g:Cpp_Temp... .
The second set of variables can point to the same files as the first set or to
another set (but both in the template directory).
If the second set is empty (i.e. all file names are empty strings: "") 
the style toggle item does not appear in the Comments-menu.
If the second set is not empty it is assumed that these files contain C++-style 
blocks and the style toggle item in the Comments-menu is present.

The template files can be written or changed by the user to fulfill special
requirements (layout for a project or work group already exists, 
file headers / blocks have to be prepared for a documentation tool, ... ).
They can hold not only comments but a complete file skeleton if this is 
necessary. So you may want to lay out your own templates.


------------------------------------------------------------------------------
5.2  TAGS                                            *csupport-templates-tags*
------------------------------------------------------------------------------

The comments in these files do not have to be personalized but they can be.
The text can contain the following tags which are replaced by the appropriate
information when the file is read in:

    |AUTHOR|
    |DATE|
    |EMAIL|
    |FILENAME|
    |YEAR|

    |AUTHORREF|
    |COMPANY|
    |COPYRIGHTHOLDER|
    |PROJECT|
    |TIME|

    |CLASSNAME|

    |basename|
    |Basename|
    |BASENAME|
    |BASENAMElegal|

    |CURSOR|

Each tag can occur more than once. The tag |CURSOR| may appear only once.

The tag |CLASSNAME| will be replaced by the class name given in a dialog box
when calling "C++ -> class" etc.

The tag |CURSOR| will be the cursor position after the block is read in.

There is no need to use any of these tags, some or all can be missing.

BASENAME TAGS. These tags return the filename with directory and suffix
stripped off:
    |Basename|       basename, unchanged
    |basename|       basename, all uppercase characters turned into lowercase
    |BASENAME|       basename, all lowercase characters turned into uppercase
    |BASENAMElegal|  basename, all lowercase characters turned into uppercase;
                     all non-word characters replaced by underscores
                     (compressed).
This can for instance be used to write a template for a header file header
with include guard:

  /*
   * =====================================================================================
   *       Filename:  |FILENAME|
   *    Description:  |CURSOR|
   *        Created:  |DATE|
   *       Revision:  none
   *         Author:  |AUTHOR| (|AUTHORREF|), |EMAIL|
   * =====================================================================================
   */
  #ifndef  |BASENAMElegal|_INC
  #define  |BASENAMElegal|_INC
  
  #endif   // ----- #ifndef |BASENAMElegal|_INC  ----- 


The template files can actually be links pointing to existing templates.


==============================================================================
6.  C/C++ DICTIONARY                                     *csupport-dictionary*
==============================================================================

The files  

 c-c++-keywords.list 
 k+r.list  
 stl_index.list  

are a part of this plugin and can be used (together with your own lists) as
dictionaries for automatic word completion.  This feature is enabled by
default. The default word lists are

  plugin_dir/c-support/wordlists/c-c++-keywords.list
  plugin_dir/c-support/wordlists/k+r.list
  plugin_dir/c-support/wordlists/stl_index.list

The variable plugin_dir will automatically be set by the plugin to one of the
following values:
  $HOME.'/.vim/'        for Linux/Unix
  $VIM.'/vimfiles/'     for Windows
If you want to use an additional list MyC.list put the following lines into
 .vimrc :

  let g:C_Dictionary_File = PLUGIN_DIR.'/c-support/wordlists/c-c++-keywords.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/k+r.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/stl_index.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/MyC.list'
  
When in file .vimrc the name PLUGIN_DIR has to be replaced by $HOME or $$VIM
(see above).  Whitespaces in the pathnames have to be escaped with a
backslash.
The right side is a comma separated list of files. Note the point at the end
of the first line (string concatenation) and the backslash in front of the 
second line (continuation line). 
You can use Vim's dictionary feature CTRL-X, CTRL-K (and CTRL-P, CTRL-N).


==============================================================================
7.  EXTEND taglist.vim FOR make AND qmake                   *csupport-taglist*     
==============================================================================

The use of the Vim plugin taglist.vim (Author: Yegappan Lakshmanan) is highly
recommended. It uses the program ctags which generates tag files for 3 dozen 
languages (Exuberant Ctags, Darren Hiebert, http://ctags.sourceforge.net).
With the following extensions the list of targets in a makefile can be shown 
in the taglist window.

1) Append the file customization.ctags to the file $HOME/.ctags .  

2) Add the following lines (from customization.vimrc) to $HOME/.vimrc :

  "
  "-------------------------------------------------------------------
  " taglist.vim : toggle the taglist window
  " taglist.vim : define the title texts for make
  " taglist.vim : define the title texts for qmake
  "-------------------------------------------------------------------
   noremap <silent> <F11>  <Esc><Esc>:Tlist<CR>
  inoremap <silent> <F11>  <Esc><Esc>:Tlist<CR>
  
  let tlist_make_settings  = 'make;m:makros;t:targets'
  let tlist_qmake_settings = 'qmake;t:SystemVariables'
  
  if has("autocmd")
    " ----------  qmake : set file type for *.pro  ----------
    autocmd BufNewFile,BufRead *.pro  set filetype=qmake
  endif " has("autocmd")

3) restart vim/gvim

The two maps will toggle the taglist window (hotkey F11) in all editing modes.
The two assignments define the headings for the (q)make sections in the
taglist window.  The autocmd set the file type 'qmake' for the filename
extension 'pro' (ctags needs this). 

==============================================================================
8.  SYNTAX BASED FOLDING                                    *csupport-folding*
==============================================================================

Syntax based folding can be enabled by adding the following lines to the file
'~/.vim/syntax/c.vim':

  syn region cBlock start="{" end="}" transparent fold
  set foldmethod=syntax
  " initially all folds open:
  set foldlevel=999

You may have to create this file first. See |folding| for more information.

==============================================================================
9.  WINDOWS PARTICULARITIES                                 *csupport-windows*
==============================================================================

The plugin should go into the directory structure below the local
installation directory $HOME/.vim/ for LINUX/UNIX and $VIM/vimfiles/ for
Windows.
The values of the two variables can be found from inside Vim:
   :echo $VIM 
or
   :echo $HOME

Configuration files:

  LINUX/UNIX :   $HOME/.vimrc  and  $HOME/.gvimrc 
  Windows    :   $VIM/_vimrc   and  $VIM/_gvimrc

Compiler settings:

It could be necessary to add further settings for your compiler.  To compile
C++-programs using a Dev-C++ installation (http://www.bloodshed.net) the
following item in $VIM/_vimrc is needed (depends on the Dev-C++ install
directory):

  let g:C_CFlags  = '-Wall -g -o0 -c -I c:\programs\dev-c++\include\g++'

==============================================================================
10.  TROUBLESHOOTING                                *csupport-troubleshooting*
==============================================================================

* I do not see any new main menu item.
  - Was the archive extracted into the right directory?

* How can I see what was loaded?
  - Use ':scriptnames' from the Vim command line. 

* No main menu item.
  - Loading of plugin files must be enabled. If not use
      :filetype plugin on
    This is the minimal content of the file '$HOME/.vimrc'. Create one if there
    is none, or better use customization.vimrc.

* Most key mappings do not work.
  - They are defined in a filetype plugin in '$HOME/.vim/ftplugin/'. Use ':filetype'
    to check if filetype plugins are enabled. If not, add the line 
      filetype plugin on
    to the file '.vimrc'.

* Some hotkeys do not work.
  - The hotkeys might be in use by your graphical desktop environment.
    Under KDE Ctrl-F9 is the hotkey which let you switch to the 9. desktop.
    The key settings can usually be redefined.

* Splint and/or CodeCheck menu item not visible. 
  - The program is not installed or not found (path not set) or not executable.

==============================================================================
11.  RELEASE NOTES                                    *csupport-release-notes*
==============================================================================

See file README.csupport .

==============================================================================
vim:tw=78:noet:ts=2:ft=help:norl:
